<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Mermaid Diagram</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.3.0/mermaid.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #diagram-container {
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
            position: relative;
            overflow: hidden;
        }
        #diagram {
            position: absolute;
            transform-origin: 0 0;
        }
        #header {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="header">Diagram</div>
    <div id="diagram-container">
        <div id="diagram"></div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false });

        const diagramContainer = document.getElementById('diagram-container');
        const diagram = document.getElementById('diagram');
        let isDragging = false;
        let startX, startY, diagramX = 0, diagramY = 0;
        let scale = 1;
        let minScale = 1;

        //the graph is waiting to be defined write to it with a py file to replace
        //the loading... part with the output graph
        const diagramDefinition = `
            graph TD
                A[loading...]    
                            `;

        mermaid.mermaidAPI.render('mermaid-diagram', diagramDefinition, (svgCode) => {
            diagram.innerHTML = svgCode;
            const svgElement = diagram.querySelector('svg');
            svgElement.style.width = '100%';
            svgElement.style.height = '100%';
            
            // Fit diagram to optimal view
            fitDiagramToOptimalView();
        });

        function fitDiagramToOptimalView() {
            const svgElement = diagram.querySelector('svg');
            if (svgElement) {
                const containerWidth = diagramContainer.clientWidth;
                const containerHeight = diagramContainer.clientHeight;
                const diagramWidth = svgElement.getBoundingClientRect().width;
                const diagramHeight = svgElement.getBoundingClientRect().height;

                // Convert 0.5 inch to pixels (assuming 96 DPI)
                const padding = 0.5 * 96;
                // Convert 2 inches to pixels
                const maxZoomOutSize = 7.5 * 96;

                // Determine if the diagram is width or height heavy
                const aspectRatio = diagramWidth / diagramHeight;
                const containerAspectRatio = containerWidth / containerHeight;

                if (aspectRatio > containerAspectRatio) {
                    // Width heavy
                    scale = (containerWidth - 2 * padding) / diagramWidth;
                    minScale = maxZoomOutSize / diagramWidth;
                    diagramX = padding;
                    diagramY = (containerHeight - diagramHeight * scale) / 2;
                } else {
                    // Height heavy
                    scale = (containerHeight - 2 * padding) / diagramHeight;
                    minScale = maxZoomOutSize / diagramHeight;
                    diagramX = (containerWidth - diagramWidth * scale) / 2;
                    diagramY = padding;
                }

                // Ensure we don't zoom out beyond the 2-inch limit
                scale = Math.max(scale, minScale);

                updateTransform();
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY * -0.0035;
            const newScale = Math.max(minScale, Math.min(10, scale + delta)); // Add upper limit of 10x zoom

            // Adjust position to zoom towards cursor
            const rect = diagramContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            diagramX = x - (x - diagramX) * newScale / scale;
            diagramY = y - (y - diagramY) * newScale / scale;
            
            scale = newScale;
            updateTransform();
        }

        function handleMouseDown(e) {
            isDragging = true;
            startX = e.clientX - diagramX;
            startY = e.clientY - diagramY;
        }

        function handleMouseMove(e) {
            if (!isDragging) return;
            diagramX = (e.clientX - startX);
            diagramY = (e.clientY - startY);
            updateTransform();
        }

        function handleMouseUp() {
            isDragging = false;
        }

        function updateTransform() {
            diagram.style.transform = `translate(${diagramX}px, ${diagramY}px) scale(${scale})`;
        }

        diagramContainer.addEventListener('wheel', handleWheel);
        diagramContainer.addEventListener('mousedown', handleMouseDown);
        diagramContainer.addEventListener('mousemove', handleMouseMove);
        diagramContainer.addEventListener('mouseup', handleMouseUp);
        diagramContainer.addEventListener('mouseleave', handleMouseUp);

        // Refit diagram on window resize
        window.addEventListener('resize', fitDiagramToOptimalView);
    </script>
</body>
</html>
