<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Conversation</title>
    <style>
        /* ... (keep existing styles) ... */
        #debug {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <button id="startButton">Start Conversation</button>
    <div id="instructions">Press and hold the Enter key to speak. Release to process your input.</div>
    <div id="status"></div>
    <div id="aiResponse"></div>
    <div id="errorMessage"></div>
    <div id="debug"></div>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let audioContext;
        let source;

        const startButton = document.getElementById('startButton');
        const statusDiv = document.getElementById('status');
        const aiResponseDiv = document.getElementById('aiResponse');
        const errorMessageDiv = document.getElementById('errorMessage');
        const debugDiv = document.getElementById('debug');

        function debug(message) {
            console.log(message);
            debugDiv.textContent += message + '\n';
        }
        function checkBrowserSupport() {
            if (!navigator.mediaDevices && !navigator.getUserMedia && !navigator.webkitGetUserMedia && !navigator.mozGetUserMedia) {
                throw new Error('This browser does not support audio recording');
            }
        }
        
        function getMediaDevices() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                return navigator.mediaDevices.getUserMedia({ audio: true });
            } else {
                const getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
                if (!getUserMedia) {
                    throw new Error('getUserMedia is not implemented in this browser');
                }
                return new Promise((resolve, reject) => {
                    getUserMedia.call(navigator, { audio: true }, resolve, reject);
                });
            }
        }

        startButton.addEventListener('click', startConversation);



        async function startConversation() {
            debug('Starting conversation...');
            try {
                checkBrowserSupport();
                debug('Browser support checked');

                debug('Requesting user media...');
                const stream = await getMediaDevices();
                debug('User media obtained successfully');

                // Check for supported MIME types
                const mimeType = getSupportedMimeType();
                debug(`Using MIME type: ${mimeType}`);

                mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = sendAudioToServer;

                debug('Sending grant permission request...');
                const response = await fetch('https://localhost:5001/grant_permission', { method: 'POST' });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                debug('Permission granted successfully');
                
                startButton.disabled = true;
                statusDiv.textContent = "Conversation started. Press and hold Enter to speak.";
                
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);

                debug('Setting up EventSource...');
                const eventSource = new EventSource('https://localhost:5001/get_ai_response');
                eventSource.onmessage = handleAIResponse;
                eventSource.onerror = (error) => {
                    console.error('EventSource failed:', error);
                    showError('Error in AI response stream. Please refresh and try again.');
                };
                debug('EventSource set up successfully');
            } catch (error) {
                console.error('Error starting conversation:', error);
                showError(`Error starting conversation: ${error.message}`);
                debug(`Error details: ${error.stack}`);
            }
        }

        function getSupportedMimeType() {
            const mimeTypes = ['audio/webm', 'audio/webm;codecs=opus', 'audio/ogg;codecs=opus'];
            for (let type of mimeTypes) {
                if (MediaRecorder.isTypeSupported(type)) {
                    return type;
                }
            }
            throw new Error('No supported MIME types found for MediaRecorder');
        }


        function handleKeyDown(event) {
            if (event.key === 'Enter' && !isRecording) {
                isRecording = true;
                audioChunks = [];
                mediaRecorder.start();
                statusDiv.textContent = "Recording...";
                debug('Started recording');
            }
        }

        function handleKeyUp(event) {
            if (event.key === 'Enter' && isRecording) {
                isRecording = false;
                mediaRecorder.stop();
                statusDiv.textContent = "Processing...";
                debug('Stopped recording');
            }
        }

        async function sendAudioToServer() {
            debug('Sending audio to server...');
            const mimeType = mediaRecorder.mimeType;
            const audioBlob = new Blob(audioChunks, { type: mimeType });
            try {
                const response = await fetch('/stream_audio', {
                    method: 'POST',
                    body: audioBlob,
                    headers: { 'Content-Type': mimeType }
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                await fetch('/stop_listening', { method: 'POST' });
                debug('Audio sent successfully');
            } catch (error) {
                console.error('Error sending audio:', error);
                showError(`Error sending audio: ${error.message}`);
                debug(`Error details: ${error.stack}`);
            }
        }

        function handleAIResponse(event) {
            const data = JSON.parse(event.data);
            if (data.type === 'speech') {
                aiResponseDiv.textContent = "AI: " + data.content;
                debug('Received AI speech response');
            } else if (data.type === 'audio') {
                playAudioResponse(data.content);
                debug('Received AI audio response');
            } else if (data.type === 'error') {
                showError(`AI Response Error: ${data.content}`);
                debug(`AI Response Error: ${data.content}`);
            }
        }

        function playAudioResponse(audioBase64) {
            debug('Playing audio response...');
            const audioData = atob(audioBase64);
            const arrayBuffer = new ArrayBuffer(audioData.length);
            const view = new Uint8Array(arrayBuffer);
            for (let i = 0; i < audioData.length; i++) {
                view[i] = audioData.charCodeAt(i);
            }

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start(0);
                debug('Audio playback started');
            }, (error) => {
                console.error('Error decoding audio data', error);
                showError('Error playing AI response audio');
                debug(`Error decoding audio: ${error}`);
            });
        }

        function showError(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
            debug(`Error: ${message}`);
        }

        // Initial debug information
        debug(`User Agent: ${navigator.userAgent}`);
        debug(`mediaDevices supported: ${!!navigator.mediaDevices}`);
        if (navigator.mediaDevices) {
            debug(`getUserMedia supported: ${!!navigator.mediaDevices.getUserMedia}`);
        }
    </script>
</body>
</html>